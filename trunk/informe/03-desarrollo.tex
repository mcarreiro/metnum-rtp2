\section{Desarrollo}

A continuación detallamos cómo fue el desarrollo de los algoritmos presentados previamente

\subsection{Page Rank}
El algoritmo de PageRank lo dividimos en dos etapas, primero la inicializaci\'on en donde se crea la matriz estoc\'astica y luego la corrida en donde se itera y calcula el pagerank hasta que la diferencia de norma entre los vectores sea menor que la tolerancia establecida.


Inicializaci\'on:


\begin{algorithm}
\caption{inicializar(c, dim, links)}\label{euclid}
\begin{algorithmic}[1]
\State $\textit{$v_{inicial}$ = vector(dim, 0);}$ \Comment{creo un vector de dim elementos y lo inicializo en 0}
\State $\textit{$v_{inicial}$[0] = 1;}$ \Comment{pongo el primer elemento en 1}
\State $\textit{$M_f$ = DOK(dim);}$ \Comment{la matriz en forma de DictionaryOfKeys representará al $M_f$}
\State $\textit{desconectados = vector()}$ \Comment{creo un vector para almacenar los nodos que no tienen salidas}
\For{$cada\ link\ en\ links$}
	\If{$link\ tiene\ salidas$}
		\State $\textit{n = link.cantidadDeSalidas;}$
		\For{$cada\ salida\ del\ nodo$}
			\State $\textit{$M_f$.definir(salida, link, 1/n );}$ \Comment{A cada salida del link actual le doy puntaje de 1/n}
		\EndFor
		\Else
			\State $\textit{desconectados.agregar(link);}$ 
	\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

Calculo del PageRank:


\begin{algorithm}
\caption{calcular()}\label{euclid}
\begin{algorithmic}[1]
\State  $\textit{v = $v_{inicial}$}$
\While{$norma > tolerancia$} \Comment{hasta que converja}
	\State $\textit{w = v}$ \Comment{guardo el vector anterior para calcular la norma Manhattan más adelante}
	\State  $\textit{sumaDesconectados = 0}$
	\For{cada link desconectado: $linkDesconectado$}
		\State $\textit{sumaDesconectados += v.elemento(linkDesconectado)}$ \Comment{}
	\EndFor
	\State $\textit{v = $M_f$ v}$ \Comment{aplico una iteraci'n del método de la potencia}
	\For{cada elemento de v: $v_i$}
		\State $\textit{$v_i$ = c*($v_i$+sumaDesconectados)+((1-c)/links.tamaño)  ;}$ \Comment{}
	\EndFor
	\State $\textit{norma = manhattan(v,w)}$ \Comment{calculo la norma Manhattan}
\EndWhile
\end{algorithmic}
\end{algorithm}
 

\subsection{HITS}
Este también lo dividimos en la etapa en la etapa de inicialización y de cálculo de sus vectores. En la primera creamos la matriz estocástica e inicializamos los vectores y en la segunda calculamos los mismos hasta que iteremos k veces o la diferencia obtenida sea menor que la tolerancia.

%Inicializaci\'on:
%\begin{lstlisting}[frame=single]  
%Creo el Dok vacio
%Para cada arista:
%	defino en el dok el nodo desde y hasta
%	
%Inicio los vectores de hubs y autoridades con todos sus valores en 1 y normalizados
	
%\end{lstlisting}

%Cálculo de vectores Hubs y Autoridades
%\begin{lstlisting}[frame=single] 
%Itero de 1 a K
%	Para el vector de hubs multiplico el dok transpuesto por el vector de autoridades y normalizo
%	Para el vector de autoridades multiplicoel dok transpuesto por el vector de hubs y normalizo
%	Si la diferencia entre el nuevo vector de hubs o autoridades con su valor previo es menor a la tolerancia termino la iteracion
%\end{lstlisting}
\subsection{Indeg}

La implementación de este algoritmo es bastante simple. Tomamos un vector inicial con ceros del tamaño de las páginas y recorremos todas las referencias de cada página hacia al resto, y por cada una de los sitios a los que visita, le sumamos en 1/cantidadLinksTotal su puntaje en el vector inicial.

\begin{algorithm}
\caption{calcular(links)}\label{euclid}
\begin{algorithmic}[1]
\State $\textit{$v_{inicial}$ = vector(links.size, 0);}$ \Comment{creo un vector de dim elementos y lo inicializo en 0}
\State $\textit{$totalAmountOfDomains$ = links.size;}$ 
\For{$cada\ link\ en\ links$}
	\If{$link\ tiene\ salidas$}
		\For{$cada\ salida\ del\ nodo$}
			\State $\textit{$v[salida] = v[salida] + 1/totalAmountOfDomains;$}$ \Comment{A cada salida del link actual le sumo el puntaje 1/totalAmountOfDomains}
		\EndFor
	\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}